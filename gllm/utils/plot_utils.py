"""
Description of this file:

This file contains utility functions for plotting and refining G-code generated by the Streamlit application that uses LLM pipelines with Langchain and Langgraph. 
The functions are used to visualize the G-code as a 3D plot and refine the G-code based on the instructions given to the application.

The functions are written in Python and use the Plotly library for the visualization.

Authors: Mohamed Abdelaal, Samuel Lokadjaja

This work was done at Software AG, Darmstadt, Germany in 2023-2024 and is published under the Apache License 2.0.
"""

import numpy as np
import matplotlib.pyplot as plt
import re
import plotly.graph_objects as go

def refine_gcode(gcode):

    commands = gcode.splitlines()
    corrected_lines = []

    for i, command in enumerate(commands):
        command = command.split(';')[0].strip()  # Remove comments and trim
        
        if not command:
            continue
        elif 'M30' in command and i != len(commands) - 1:
            # skip M30
            continue
        
        corrected_lines.append(command)
    
    return "\n".join(corrected_lines)

def parse_coordinates(command):
    # Regular expression to find coordinates
    coord_pattern = re.compile(r'[XYZIJR]-?\d+\.?\d*')
    coords = coord_pattern.findall(command)
    coord_dict = {}
    for coord in coords:
        if coord.startswith('X'):
            coord_dict['X'] = float(coord[1:])
        elif coord.startswith('Y'):
            coord_dict['Y'] = float(coord[1:])
        elif coord.startswith('Z'):
            coord_dict['Z'] = float(coord[1:])
        elif coord.startswith('I'):
            coord_dict['I'] = float(coord[1:])
        elif coord.startswith('J'):
            coord_dict['J'] = float(coord[1:])
        elif coord.startswith('R'):
            coord_dict['R'] = float(coord[1:])
    return coord_dict


def parse_gcode(gcode):
    x_points, y_points = [], []
    x, y = 0, 0  # Initialize starting point
    # x_points.append(x)
    # y_points.append(y)
    
    for command in gcode.splitlines():
        
        command = command.split(';')[0].strip()  # Remove comments and trim
        
        if not command:
            continue
        elif 'M30' in command:
            # End of program
            break
        elif 'G00' in command or 'G0 ' in command:
            print("rapid positioning", command)
            # Rapid positioning
            coords = parse_coordinates(command)
            x = coords.get('X', x)
            y = coords.get('Y', y)
            print(command, x, y)
            x_points.append(x)
            y_points.append(y)
        elif 'G01' in command or 'G1 ' in command:
            # Linear interpolation
            print("linear interpolation", command)
            coords = parse_coordinates(command)
            print(command, x, y)
            x = coords.get('X', x)
            y = coords.get('Y', y)
            x_points.append(x)
            y_points.append(y)
        # Handle circular interpolation if present
        elif 'G02' in command or 'G2 ' in command or 'G03' in command or 'G3 ' in command:
            print("plotting Circualar shape!", command)
            # Circular interpolation
            coords = parse_coordinates(command)
            i_center = coords.get('I', 0)
            j_center = coords.get('J', 0)
            radius = coords.get('R', None)

            if radius is not None:
                # Calculate center of the arc from radius
                dx = x - (x + radius)
                dy = y - (y + radius)
                center_x = x + np.cos(np.arctan2(dy, dx)) * radius
                center_y = y + np.sin(np.arctan2(dy, dx)) * radius
            else:
                center_x = x + i_center
                center_y = y + j_center
            
            # Determine the end position
            if 'X' in coords and 'Y' in coords:
                x_end = coords.get('X', x)
                y_end = coords.get('Y', y)
            else:
                # If no end coordinates are provided, compute them assuming a complete circle
                x_end = x
                y_end = y

            # Calculate angles for the arc
            start_angle = np.arctan2(y - center_y, x - center_x)
            end_angle = np.arctan2(y_end - center_y, x_end - center_x)

            # Generate points along the arc
            if 'G02' in command or 'G2' in command:  # Clockwise
                if start_angle <= end_angle:
                    start_angle += 2 * np.pi
            elif 'G03' in command or 'G3' in command:  # Counterclockwise
                if start_angle >= end_angle:
                    end_angle += 2 * np.pi

            angles = np.linspace(start_angle, end_angle, 100)
            arc_x = center_x + radius * np.cos(angles) if radius is not None else center_x + np.sqrt(i_center**2 + j_center**2) * np.cos(angles)
            arc_y = center_y + radius * np.sin(angles) if radius is not None else center_y + np.sqrt(i_center**2 + j_center**2) * np.sin(angles)
            x_points.extend(arc_x)
            y_points.extend(arc_y)
            # Update current position to end of arc
            x, y = x_end, y_end
        
        else:
            # skipp all other irrelevant commands
            continue
    
    return x_points, y_points


def plot_gcode(gcode):

    x_points, y_points = parse_gcode(gcode)

    plt.figure(figsize=(10, 6))
    plt.plot(x_points, y_points, marker='o')
    plt.title('CNC Path Plot')
    plt.xlabel('X Axis')
    plt.ylabel('Y Axis')
    plt.grid(True)
    plt.axis('equal')
    return plt


def plot_user_specification(parsed_parameters):
    """Plots the CNC task in 2D."""
    
    # Handle None or invalid parsed_parameters
    if parsed_parameters is None:
        fig, ax = plt.subplots(figsize=(6, 4))
        ax.text(0.5, 0.5, 'No parameters available for plotting', 
                ha='center', va='center', transform=ax.transAxes, fontsize=12)
        ax.set_title('CNC Task Visualization (2D) - No Data')
        return plt
    
    if not isinstance(parsed_parameters, dict):
        fig, ax = plt.subplots(figsize=(6, 4))
        ax.text(0.5, 0.5, 'Invalid parameters format for plotting', 
                ha='center', va='center', transform=ax.transAxes, fontsize=12)
        ax.set_title('CNC Task Visualization (2D) - Invalid Data')
        return plt
    
    # Check for required keys with safe access
    wp_dims = parsed_parameters.get('workpiece_diemensions', [50, 50])  # Default dimensions
    start_point = parsed_parameters.get('starting_point', [0, 0])  # Default start point
    tool_path = parsed_parameters.get('tool_path', [(0, 0, 0), (10, 10, 0)])  # Default path
    cut_depth = parsed_parameters.get('cut_depth', [1])  # Default depth
    
    # Ensure we have valid data
    if not wp_dims or len(wp_dims) < 2:
        wp_dims = [50, 50]  # Default workpiece dimensions
    
    if not start_point or len(start_point) < 2:
        start_point = [0, 0]  # Default starting point
    
    if not tool_path or len(tool_path) == 0:
        tool_path = [(0, 0, 0), (10, 10, 0)]  # Default tool path
    
    if not cut_depth or len(cut_depth) == 0:
        cut_depth = [1]  # Default cut depth

    fig, ax = plt.subplots(figsize=(6, 4))

    try:
        # Plot workpiece as a rectangle
        rect = plt.Rectangle((0, 0), wp_dims[0], wp_dims[1], 
                             linewidth=2, edgecolor='k', facecolor='lightgray')
        ax.add_patch(rect)

        # Plot tool path
        x_path, y_path, _ = zip(*tool_path)  # Ignore z-coordinates for 2D plot

        # Move to starting point if not already at the beginning
        if tool_path and (start_point[0], start_point[1]) != tool_path[0]:
            x_path = (start_point[0],) + x_path
            y_path = (start_point[1],) + y_path

        ax.plot(x_path, y_path, 'r-', linewidth=2, label='Tool Path')

        ax.set_xlabel('X (mm)')
        ax.set_ylabel('Y (mm)')
        ax.set_title('CNC Task Visualization (2D)')
        ax.legend()

        # Set axis limits to match workpiece dimensions
        ax.set_xlim([0, wp_dims[0]])
        ax.set_ylim([0, wp_dims[1]])

        # Add cut depth as text annotation
        ax.text(0.05, 0.95, f'Cut Depth: {cut_depth[0]}mm', 
                transform=ax.transAxes, verticalalignment='top')

        plt.gca().set_aspect('equal', adjustable='box')  # Equal aspect ratio
        
    except Exception as e:
        # If anything goes wrong, show an error message
        ax.clear()
        ax.text(0.5, 0.5, f'Error plotting visualization:\n{str(e)}', 
                ha='center', va='center', transform=ax.transAxes, fontsize=10)
        ax.set_title('CNC Task Visualization (2D) - Error')
    
    return plt


# def plot_user_specification(parsed_parameters):
#     """Plots the CNC task in 2D using Plotly."""

#     wp_dims = parsed_parameters['workpiece_diemensions']
#     start_point = parsed_parameters['starting_point']
#     tool_path = parsed_parameters['tool_path']
#     cut_depth = parsed_parameters['cut_depth'][0]

#     # Create Plotly figure
#     fig = go.Figure()

#     # Plot workpiece as a rectangle
#     fig.add_shape(
#         type="rect",
#         x0=0,
#         y0=0,
#         x1=wp_dims[0],
#         y1=wp_dims[1],
#         line=dict(color="black", width=2),
#         fillcolor="lightgray",
#     )

#     # Plot tool path
#     x_path, y_path, _ = zip(*tool_path)  # Ignore z-coordinates for 2D plot

#     # Move to starting point if not already at the beginning
#     if tool_path and (start_point[0], start_point[1]) != tool_path[0]:
#         x_path = [start_point[0]] + list(x_path)
#         y_path = [start_point[1]] + list(y_path)

#     print(tool_path)

#     fig.add_trace(
#         go.Scatter(
#             x=list(x_path), 
#             y=list(y_path), 
#             mode="lines", 
#             line=dict(color="red", width=2),
#             name="Tool Path"
#         )
#     )

#     # Set axis labels and title
#     fig.update_layout(
#         xaxis_title="X (mm)",
#         yaxis_title="Y (mm)",
#         title="CNC Task Visualization (2D)",
#         showlegend=True,  # Show legend
#         xaxis=dict(range=[0, wp_dims[0]]),  # Set x-axis limits
#         yaxis=dict(range=[0, wp_dims[1]]),  # Set y-axis limits
#         annotations=[
#             dict(
#                 x=0.05,
#                 y=0.95,
#                 xref="paper",  # Relative to figure (0 to 1)
#                 yref="paper",
#                 text=f"Cut Depth: {cut_depth}mm",
#                 showarrow=False,
#                 align="left",
#                 valign="top"
#             )
#         ]
#     )

#     # Equal aspect ratio
#     fig.update_yaxes(
#         scaleanchor="x",
#         scaleratio=1,
#     )

#     return fig